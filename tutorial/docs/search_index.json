[["index.html", "Supplementary Information: Cellxgene VIP unleashes full power of interactive visualization and integrative analysis of scRNA-seq, spatial transcriptomics, and multiome data Chapter 1 Getting started with cellxgene VIP 1.1 Why use cellxgene VIP? 1.2 Getting Set up 1.3 Authors", " Supplementary Information: Cellxgene VIP unleashes full power of interactive visualization and integrative analysis of scRNA-seq, spatial transcriptomics, and multiome data Chapter 1 Getting started with cellxgene VIP This is a cellxgene VIP supplementary information including a tutorial book written in Bookdown. 1.1 Why use cellxgene VIP? To meet the growing demands from scientists to effectively extract deep insights from single cell RNA sequencing, spatial transcriptomics, and emerging multiome datasets, we developed cellxgene VIP (Visualization In Plugin), a frontend interactive visualization plugin of cellxgene framework, which greatly expanded capabilities of the base tool in the following aspects. First, it generates a comprehensive set of over eighteen commonly used quality control and analytical plots in high resolution with highly customizable settings in real time. Second, it provides more advanced analytical functions to gain insights on cellular compositions and deep biology, such as marker gene identification, differential gene expression analysis, and gene set enrichment analysis. Third, it empowers advanced users to perform analysis in a Jupyter Notebook like environment, dubbed Command Line Interface (CLI) by programming in Python and/or R directly without limiting themselves to functional modules available via graphical user interface (GUI). Finally, it pioneers methods to visualize multi-modal data, such as spatial transcriptomics embedding aligned with histological image on one slice or multiple slices in a grid format, and the latest 10x Genomic Multiome dataset where both DNA accessibility and gene expression in the same cells are measured, under the same framework in an integrative way to fully leverage the functionalities mentioned above. Taken together, the open-source tool makes large scale single cell data visualization and analysis more accessible to biologists in a user-friendly manner and fosters computational reproducibility by simplifying data and code reuse through the CLI. Going forward, it has the potential to become a crowdsourcing ecosystem for the scientific community to contribute even more modules to the Swiss Army knife of single cell data exploration tools. 1.2 Getting Set up 1.2.1 Execute anaconda bash ~/Downloads/Anaconda3-2020.02-Linux-x86_64.sh If anaconda is not installed on server, you can install it following anaconda documentation (https://docs.anaconda.com/anaconda/install/linux/) ### Create and enable conda environment # clone repo from cellxgene VIP github git clone https://github.com/interactivereport/cellxgene_VIP.git cd cellxgene_VIP # conda environment source &lt;path to Anaconda3&gt;/etc/profile.d/conda.sh (Default: /opt/anaconda3/etc/profile.d/conda.sh) conda config --set channel_priority flexible conda env create -n &lt;env name, such as: VIP&gt; -f VIP.yml (system-wide R) or VIP_conda_R.yml (local R under conda, no root privilege needed) Activate conda environment conda activate &lt;env name, such as: VIP&gt; or source activate &lt;env name&gt; 1.2.2 Cellxgene installation Install cellxgene by running config.sh in “cellxgene_VIP” directory ./config.sh 1.2.3 R dependencies Install all required R packages on linux: export LIBARROW_MINIMAL=false # ensure that the right instance of R is used. e.g. system-wide: /bin/R or /usr/bin/R ; local R under conda: ~/.conda/envs/VIP_conda_R/bin/R which R R -q -e &#39;if(!require(devtools)) install.packages(&quot;devtools&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(Cairo)) devtools::install_version(&quot;Cairo&quot;,version=&quot;1.5-12&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(foreign)) devtools::install_version(&quot;foreign&quot;,version=&quot;0.8-76&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(ggpubr)) devtools::install_version(&quot;ggpubr&quot;,version=&quot;0.3.0&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(ggrastr)) devtools::install_version(&quot;ggrastr&quot;,version=&quot;0.1.9&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(arrow)) devtools::install_version(&quot;arrow&quot;,version=&quot;2.0.0&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(Seurat)) devtools::install_version(&quot;Seurat&quot;,version=&quot;3.2.3&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(rmarkdown)) devtools::install_version(&quot;rmarkdown&quot;,version=&quot;2.5&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(tidyverse)) devtools::install_version(&quot;tidyverse&quot;,version=&quot;1.3.0&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(viridis)) devtools::install_version(&quot;viridis&quot;,version=&quot;0.5.1&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(BiocManager)) devtools::install_version(&quot;BiocManager&quot;,version=&quot;1.30.10&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(fgsea)) BiocManager::install(&quot;fgsea&quot;)&#39; # These should be already installed as dependencies of above packages R -q -e &#39;if(!require(dbplyr)) devtools::install_version(&quot;dbplyr&quot;,version=&quot;1.0.2&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(RColorBrewer)) devtools::install_version(&quot;RColorBrewer&quot;,version=&quot;1.1-2&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(glue)) devtools::install_version(&quot;glue&quot;,version=&quot;1.4.2&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(gridExtra)) devtools::install_version(&quot;gridExtra&quot;,version=&quot;2.3&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(ggrepel)) devtools::install_version(&quot;ggrepel&quot;,version=&quot;0.8.2&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(MASS)) devtools::install_version(&quot;MASS&quot;,version=&quot;7.3-51.6&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; R -q -e &#39;if(!require(data.table)) devtools::install_version(&quot;data.table&quot;,version=&quot;1.13.0&quot;,repos = &quot;http://cran.us.r-project.org&quot;)&#39; 1.2.4 Run cellxgene by h5ad file You can aslo run cellxgene by specifying a h5ad file, which stores scRNA-seq data along with a host and a port. Use ‘ps’ to find used ports to spare. Please see https://chanzuckerberg.github.io/cellxgene/posts/launch for details ps -ef | grep cellxgene Rscript -e &#39;reticulate::py_config()&#39; # Run the following command if the output of the above command doesn&#39;t point to the Python in your env. export RETICULATE_PYTHON=`which python` cellxgene launch --host &lt;xxx&gt; --port &lt;xxx&gt; --disable-annotations --verbose &lt;h5ad file&gt; 1.2.5 Cellxgene on web browser chrome is preferred, version 87.0.4280.88 or 87.0.4280.141 is used. Users can access . Following screenshot is what you should be able to see in console of chrome developer tools. 1.3 Authors Keijie Li (kejie.li@biogen.com), Associate Director at Biogen in the research department. Main author and content wrangler. Zhengyu Ouyang, Associate Director of Bioingormatics at BioinfoRx. Content wrangler. Baohong Zhang (baohong.zhang@biogen.com), Head of Genome Informatics at Biogen in the research department. Corresponding author and content wrangler. The development and delivery of this material has also contributed by: Yirui Chen (yirui.chen@bigen.com), Biogen Inc. Dongdong Lin (dongdong.lin@biogen.com), Biogen Inc. Michael Mingueneau (michael.mingueneau@bioigen.com), Biogen Inc. Jake Gagnon (jake.gagnon@biogen.com), Biogen Inc. Will Chen (wwchen@post.harvard.edu), Biogen Inc. David Sexton (david.sexton@biogen.com), Biogen Inc. "],["how-to-use-cellxgene-vip.html", "Chapter 2 How to use Cellxgene VIP 2.1 Graphical user interface of cellxgene and VIP 2.2 Cell selection by categorial annotations 2.3 Cell selection by brushing on distribution of continues variables 2.4 Free hand Lasso selection on dots representing cells 2.5 VIP – Global Setting 2.6 VIP – Add Genes / Gene Sets 2.7 VIP – Violin Plot 2.8 VIP – Heatmap 2.9 VIP – Embedding 2.10 VIP – Dot Plot 2.11 VIP – Track Plot 2.12 VIP – Density Plot 2.13 VIP – Density Scatter Plot 2.14 VIP – Dual Genes 2.15 VIP – Sankey Diagram 2.16 VIP – Stacked Barplot 2.17 VIP – Gene Specificity 2.18 VIP – Gene Detected 2.19 VIP – DEG (Differential Expressed Genes) 2.20 VIP - Pre-computed DEG 2.21 VIP – Marker Genes 2.22 VIP - CosMx 2.23 VIP - Spatial Transcriptomics 2.24 VIP – Command Line Interface 2.25 VIP – Comb. &amp; Abbr. 2.26 VIP – Other Functions", " Chapter 2 How to use Cellxgene VIP 2.1 Graphical user interface of cellxgene and VIP The main window of cellxgene is divided into three regions, the left panel mainly displays categorial annotations, brief description of the data set and initial graphics setting, specifically embedding and coloring of cells. On the right panel, it hosts continuous variables, such as qc metrics shown in histogram with x, y corresponding to values of a measurement and numbers of cells, respectively. More importantly, cells shown as individual dots are presented in the center panel based on a selected embedding and colored by either categorial annotations or continuous variables, which is indicated by pressed rain drop icon, e.g., cell_type in Supplementary Fig. 1a. Supplementary Fig. 1a. Cellxgene main window, functional icons and minimized VIP bar next to cellxgene logo. Supplementary Fig. 1b. VIP (Visualization in Plugin) window and controls of user interface. The cursor will change to corresponding icon when mouse hovers over control anchors inside the window. In the case of missing title bar after operation, changing the size of outside browser window (not VIP window) will always bring the VIP window back to the original location near the cellxgene logo. 2.2 Cell selection by categorial annotations Supplementary Fig. 2. Cell selection by categorial annotation. Selected B cells are shown in bold dots and highlighted in purple color when hovering the mouse over the cluster. It is an overlap operation when categories from multiple annotations are checked to make the final selection. E.g., if male from sex is also checked besides B cells, it means cells from B cells cluster of male samples are selected. Note: Click “1:” or “2:” button to save cell selection into group 1 or 2 2.3 Cell selection by brushing on distribution of continues variables Supplementary Fig. 3. Cell selection by brushing the ranges of continuous variables. Low- and high-end values are shown at the top corners of the brushing boxes in dark gray. Note: Histograms of expression values of genes can by brushed as well to get cells expressing certain genes in the range. 2.4 Free hand Lasso selection on dots representing cells From the cell visualization panel, user can freely select a cluster of cells of interest by using ‘Lasso’ selection tool. The selected cluster of cells can also be added as a group for downstream analysis in cellxgene VIP. Supplementary Fig. 4. Select cells by using free hand Lasso selection tool and add these cells as a group for further analysis in cellxgene VIP. Note: Please try to draw as close as possible to the starting point in the end to make an enclosed shape to ensure successfully lasso selection. 2.5 VIP – Global Setting User can set parameters for figure plotting that control plotting functions except CLI. ‘split_show’ branch of Scanpy offers better representation of Stacked Violin and Dot Plot comparing to master branch. Supplementary Fig. 5. Setting parameters for figure plotting. Scaled data have zero mean and unit variance per gene. This was performed by calculating z-scores of the expression data using Scanpy’s scale function. (Scanpy pp.scale function: Scale data to unit variance and zero mean.) We provide flexibility to allow 1) scale to unit variance or not; 2) Zero centered or not; 3) Capped at max value after scaling. We recommend using scaled data for plotting/visualization while using non-scaled data for differential gene expression analysis. Note: Dot plot is one exception in visualization category which uses non-scaled data for meaningful interpretation. 2.6 VIP – Add Genes / Gene Sets Cellxgene VIP allows user to add any genes or gene sets for extensive exploration and visualization. User can either type a list of gene in the textbox or create sets of genes to be grouped together in plots. Then the genes will be automatically listed for plotting in other functional modules after checking availability in the dataset. Supplementary Fig. 6. Add gene or gene sets for plotting. Note: The cursor will turn to cross icon while hovering over a gene name, then click to delete the gene. 2.7 VIP – Violin Plot To visualize gene expression across annotation categories (e.g., cell type, sex, batch, or treatment), the tool provides four distinct violin plot configurations based on combinations of: * Single or multiple genes * Single or multiple categorical factors These configurations are organized into four tabs, allowing users to flexibly explore relationships between gene expression patterns and experimental variables. Step 1. User needs to select the group(s) of cells for plotting. These groups can be created by using selection tools illustrated in tutorial section 2, 3 and/or 4. Initially, all of cells are gathered in ‘Group 1’ by default. Step 2. Select a gene from the gene list which could be added as shown in section 6. An expression level cutoff can be set to further filter out cells with low level expression of such gene. Step 3. Select the annotation to group cells for plotting. Step 4. Execute plotting, get plotting data (i.e., gene expression), manipulate image (e.g., zoom in/out) or save the image. Supplementary Fig. 7a. Violin plot of gene expression values of a gene grouped by cell type. Note: Figure resolution and format can be set in “Global Setting” tab as shown in tutorial section 5. Beyond plotting expression values of a gene, stacked violin plots in the Multi-genes and Multi-genes/Multi-factors tabs allow plotting of multiple genes together grouped by one or two categorical factors. Supplementary Fig. 7b. Stacked Violin plot of multiple genes and/or gene set. Note: If collapsing of gene sets is set to ‘Yes’, average gene expression of genes in a set is used for plotting. 2.8 VIP – Heatmap To show or compare the expression level (i.e., expression value or expression Z-score) of multiple genes among the selected group of cells. Supplementary Fig. 8. Heatmap of gene expression in cells grouped by annotations. 2.9 VIP – Embedding To plot the embedding (UMAP, tSNE, or spatial) of cells in the selected group(s). One of pre-computed and loaded embeddings can be selected. The user can color cells in the embedding plots by multiple annotations (e.g., cell_type, diagnosis). Besides coloring cells by annotations, user can color cells based on gene expression level of selected genes in the embedding plots. Supplementary Fig. 9. Embedding plotting of expression level of genes or gene set in the cells split by categories of an annotation. 2.10 VIP – Dot Plot To show the fraction of cells (annotated by dot size) expressing a gene in each group and the averaged expression level of the gene (annotated by color intensity) in the group. Supplementary Fig. 10. Dot plotting of the fraction of cells expressing genes above a cutoff in each categorie of the selected annotation. Note: The number of cells represented by side bar chart are always numbers of cells distributed in each category of certain annotation without filtering. It will give an accurate estimate of number of cells in each bubble in the plot. The use of the plot is only meaningful when the counts matrix contains zeros representing no gene counts. Its visualization does not work for scaled or corrected matrices in which zero counts had been replaced by other values, see https://scanpy-tutorials.readthedocs.io/en/multiomics/visualizing-marker-genes.html#Dot-plots. 2.11 VIP – Track Plot To show the expression of gene(s) of individual cells as vertical lines grouped by the selected annotation on x-axis. Instead of a color scale, the gene expression is represented by height. Supplementary Fig. 11. Track plotting of expression of genes or gene set in each category of the selected annotation. Gene expression levels are represented by the heights of vertical lines. 2.12 VIP – Density Plot To show the density of gene(s) expression in the cells annotated by category in the selected group(s) of cells. A density plot is a representation of the distribution of a numeric variable. It uses a kernel density estimate to show the probability density function of the variable (see more). It is a smoothed version of the histogram and is used in the same concept. The bandwidth defines how close to a value point the distance between two points must be to influence the estimation of the density at the point. A small bandwidth only considers the closest values, so the estimation is close to the data. A large bandwidth considers more points and gives a smoother estimation. Supplementary Fig. 12. Density plotting of the expression of genes in each group split by one annotation while colored by another. 2.13 VIP – Density Scatter Plot Besides plotting of expression density of single gene, density scatter plot allows to explore the joint expression density of two genes in the cells expressing both genes above a cutoff. Supplementary Fig. 13. Density scatter plotting of expression of two genes in the selected cells. 2.14 VIP – Dual Genes To view the relationship of expression levels of two genes in selected cells. It is based on the embedding plot of cells while coloring cells according to the expression levels of gene(s) in each cell. Supplementary Fig. 14. Embedding plotting of the expression of two genes in the selected cell group(s). 2.15 VIP – Sankey Diagram Sankey diagram shows the flow of gene expression and annotations linked by cells. Gene expression is divided equally into bins so user can view distribution relationship between gene expression and annotations. The diagram is also shown in an interactive way so that user can change the layout by selecting several items (e.g., thin or thick on color bar, small or large space) from the panel. Also, the user can drag these small boxes on the plot to get preferred layout and save it as high resolution SVG figure. In addition, when you hover over mouse on a box, you can get detailed information about the source and target of flow Supplementary Fig. 15. Sankey diagram provides quick and easy way to explore the inter-dependent relationship of variables. 2.16 VIP – Stacked Barplot To show the distribution of cells among categories of an annotation and/or ranges of expression of a gene. Only two factors from annotations or genes can be chosen. The plot allows user to explore the distribution of cells in different views interactively. Supplementary Fig. 16. The distribution of cells in the selected group(s) regarding categories of an annotation and expression ranges of a gene by three different layout:count, streamgraph, proportion. 2.17 VIP – Gene Specificity To show the distribution of gene expression among categories of an annotation Supplementary Fig. 17. The distribution of gene expression among categories of an annotation 2.18 VIP – Gene Detected To show the number of genes expressed above the specified expression cut-off in the selected group(s) of cells. Supplementary Fig. 18. The number of genes with expression over the cut-off in the cells from the selected group(s) of cells. 2.19 VIP – DEG (Differential Expressed Genes) Besides plotting functions, cellxgene VIP also provides differential analysis between two selected groups of cells to identify differential expressed genes. Three differential analysis statistical test methods are provided including Welch’s t-test, Wilcoxon rank test and Wald’s test. The statistical test results are presented in a table format including log2 Fold change, p-value and adjusted p-value (i.e, FDR value). Please note, we provide users with simple test methods for quick exploration within the interactive framework. However, there would be covariates need to be considered in a proper statistical test. Please consult your stats experts for appropriate test by using the right test method and right model. Volcano plotting is also provided to show the log2FC vs. -log10(FDR) relationship for all genes. The user can select the gene(s) from the pre-selected gene list to be highlighted with text in the volcano plot. Supplementary Fig. 19. DEG analysis between the selected group(s) with volcano plots Note: The data used by DEG is unscaled (please refer to description of the dataset to find out what preprocessing was done on the data). Scaling control in the Global Setting does not apply to DEG. The three methods: ‘Welch’s t-test’ uses t-test (assuming underlining data with normal distributions) this uses cellxgene t-test implementation, ‘Wilcoxon rank test’ uses Wilcoxon rank-sum test (does not assume known distributions, non-parametric test) and ‘Wald’s test’ uses Wald Chi-Squared test which is based on maximum likelihood. ‘Wilcoxon rank test’ and ‘Wald’s test’ use diffxpy’s implementation. Gene set enrichment analysis (GSEA) can be enabled for the DEGs on the gene sets of interest. 2.20 VIP - Pre-computed DEG In addition, cellxgene VIP shows the differential analysis within some pre-computed annotated groups. Supplementary Fig. 20. Pre-computed DEG analysis between/ among the selected pre-defubed group(s) with volcano plots and bubble heatmap. 2.21 VIP – Marker Genes This functional module allows user to identify marker genes in the selected group(s) (more than 2, if 2 groups, please use DEG) of cells by annotation categories. Four methods are provided for detecting marker genes including logreg, t-test, Wilcoxon, and t-testoverest_var. For each identified marker gene, the gene name, scores (the z-score underlying the computation of a p-value for each gene for each group) and assigned group are listed in the output table. In each annotation category, top ranked marker genes (this example shows top 10) will be plotted by score in comparison to the rest of the categories. Supplementary Fig. 21. Marker genes detection in the selected group(s) of cells regarding the selected annotation categories. Note: The four methods implementations by calling scanpy.tl.rank_genes_groups function: ‘logreg’ uses logistic regression, ‘t-test’ uses t-test, ‘wilcoxon’ uses Wilcoxon rank-sum, and ‘t-test_overestim_var’ overestimates variance of each group. 2.21.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 2.22 VIP - CosMx The CosMx function tab will appear in the left menu when the dataset is in the nanoString CosMx data format. This feature enables users to visualize gene expression on-site at the resolution of individual cells. Supplementary Fig. 22. nanoString CosMx spatial transcriptomics analysis. Please check section 3.6 for preparing the spatial data set for visualization. 2.22.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 2.23 VIP - Spatial Transcriptomics This feature enables users to visualize spatial image overlays the embedding plot for 10X visium data. Supplementary Fig. 23. 10X visium spatial transcriptomics analysis. Please check section 3.6 for preparing the spatial data set for visualization. 2.24 VIP – Command Line Interface Although cellxgene VIP provides a rich set of visualization modules as shown above, command line interface is also built to allow unlimited visualization and analytical capabilities by power user who know how to program in Python / R languages. Supplementary Fig. 24. Command line interface for the user to program for advanced plotting and statistical analysis. Note: In CLI the AnnData (adata) object is available by default, and it is processed as ‘Description’ of the dataset states (i.e.: normalized and log transformed, but not scaled etc.). Settings in ‘Global Setting’ tab won’t apply to CLI. 2.25 VIP – Comb. &amp; Abbr. The user can combine multiple annotations to create a combinatorial annotation to group cells in many plotting modules, e.g., stacked violin and dot plot. Firstly, the user clicks ‘uncheck all annotations’ and, secondly goes to the annotation panel in main window to select annotation categories to be combined, e.g., diagnosis (Control and MS) combined with sex (female and male). After clicking on ‘Create’ button, all possible combinatorial names will be listed and ‘Custom_combine’ will be automatically available as an option in ‘Group by’ drop down menu of many plotting functions. The user can also rename each annotation by creating abbreviations to shorten axis labels in figures. Supplementary Fig. 25. Comb. &amp; Abbr. function allows user to create new annotation by combining multiple annotations and abbreviations to shorten axis labels in figures especially when custom combinatorial names are used. 2.26 VIP – Other Functions There are other convenient functions available to user, such as ‘Save’ or ‘Load’ session, ‘Check All Annotations’ and ‘Brush’. ‘Save’ or ‘Load’ session are used to save the current cell selections and parameter settings to text file or load a previously saved session file in the tool for visualization. ‘Check All Annotations’ is used to check all categorical selection boxes of annotations on the left panel. ‘Brush’ is to display exactly these selected ranges from histograms of variables on the right panel in a nice table that is not available in original cellxgene. Supplementary Fig. 26. Other functions allow user to ‘Save’ or ‘Load’ session information, ‘Check All Annotations’ and show values of brushed ranges on histograms. "],["methods.html", "Chapter 3 Methods 3.1 Client-side Integration by a jsPanel Window (VIP) 3.2 Server-side Integration 3.3 Communication between VIP and cellxgene web GUI 3.4 Diffxpy Integration 3.5 Create a h5ad file from Seurat object 3.6 Prepare Spatial Data for Visualization", " Chapter 3 Methods 3.1 Client-side Integration by a jsPanel Window (VIP) Related lines in config.sh file. sed -i &quot;s|&lt;div id=\\&quot;root\\&quot;&gt;&lt;/div&gt;|$(sed -e &#39;s/[&amp;\\\\/]/\\\\&amp;/g; s/|/\\\\|/g; s/$/\\\\/;&#39; -e &#39;$s/\\\\$//&#39; index_template.insert)\\n&amp;|&quot; &quot;cellxgene/client/index_template.html&quot; The content of the index_template.insert file. &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/stackedbar/d3.v3.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/jspanel.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/jspanel.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/extensions/modal/jspanel.modal.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/extensions/tooltip/jspanel.tooltip.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/extensions/hint/jspanel.hint.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/extensions/layout/jspanel.layout.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/extensions/contextmenu/jspanel.contextmenu.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://interactivereport.github.io/cellxgene_VIP/static/jspanel/dist/extensions/dock/jspanel.dock.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // execute JavaScript code in panel content var setInnerHTML = function(elm, html) { elm.innerHTML = html; Array.from(elm.querySelectorAll(&#39;script&#39;)).forEach( oldScript =&gt; { const newScript = document.createElement(&#39;script&#39;); Array.from(oldScript.attributes) .forEach( attr =&gt; newScript.setAttribute(attr.name, attr.value) ); newScript.appendChild(document.createTextNode(oldScript.innerHTML)); oldScript.parentNode.replaceChild(newScript, oldScript); }); } var plotPanel = jsPanel.create({ panelSize: &#39;190 0&#39;, position: &#39;left-top 160 6&#39;, dragit: { containment: [-10, -2000, -4000, -2000] }, // set dragging range of VIP window boxShadow: 1, border: &quot;solid #D4DBDE thin&quot;, contentOverflow: &#39;scroll scroll&#39;, // adding scrolling bars headerControls:{ close: &#39;remove&#39;, minimize: &#39;remove&#39;, maximize: &#39;remove&#39; }, headerTitle: function () {return &#39;&lt;strong&gt;Visualization in Plugin&lt;/strong&gt;&#39;}, contentAjax: { url: window.location.href.replace(/\\\\\\/+$/,&#39;&#39;)+&#39;/static/interface.html&#39;, done: function (panel) { setInnerHTML(panel.content, this.responseText); } }, onwindowresize: function(event, panel) { var jptop = parseInt(this.currentData.top); var jpleft = parseInt(this.currentData.left); if (jptop&lt;-10 || window.innerHeight-jptop&lt;10 || window.innerWidth-jpleft&lt;10 || jpleft+parseInt(this.currentData.width)&lt;10) { this.reposition(&quot;left-top 160 6&quot;); } }, onunsmallified: function (panel, status) { this.reposition(&#39;center-top -370 180&#39;); this.resize({ width: 740, height: function() { return Math.min(480, window.innerHeight*0.6);} }); }, onsmallified: function (panel, status) { this.reposition(&#39;left-top 160 6&#39;); this.style.width = &#39;190px&#39;; } }).smallify(); plotPanel.headerbar.style.background = &quot;#D4DBDE&quot;; &lt;/script&gt; All functional VIP HTML and JavaScript code will be in a new file called “interface.html”, which is out of cellxgene code base. 3.2 Server-side Integration Related in config.sh file. echo &#39; from server.app.VIPInterface import route @webbp.route(&quot;/VIP&quot;, methods=[&quot;POST&quot;]) def VIP(): return route(request.data,current_app.app_config)&#39; &gt;&gt; cellxgene/server/app/app.py cd cellxgene make pydist make install-dist cd .. ## finished setting up ------ ./update.VIPInterface.sh all The content of update.VIPInterface.sh file. #!/usr/bin/env bash if [ -n &quot;$1&quot; ]; then echo &quot;usually update once&quot; fi ## finished setting up ------ strPath=&quot;$(python -c &#39;import site; print(site.getsitepackages()[0])&#39;)&quot; strweb=&quot;${strPath}/server/common/web/static/.&quot; cp VIPInterface.py $strPath/server/app/. cp interface.html $strweb cp vip.env $strPath/server/app/. 2&gt;/dev/null | true cp fgsea.R $strPath/server/app/. mkdir -p $strPath/server/app/gsea cp gsea/*gmt $strPath/server/app/gsea if [ -n &quot;$1&quot; ]; then cp Density2D.R $strPath/server/app/. cp bubbleMap.R $strPath/server/app/. cp violin.R $strPath/server/app/. cp volcano.R $strPath/server/app/. cp browserPlot.R $strPath/server/app/. if [ &quot;$(uname -s)&quot; = &quot;Darwin&quot; ]; then sed -i .bak &quot;s|route(request.data,current_app.app_config, \\&quot;/tmp\\&quot;)|route(request.data,current_app.app_config)|&quot; &quot;$strPath/server/app/app.py&quot; sed -i .bak &quot;s|MAX_LAYOUTS *= *[0-9]\\+|MAX_LAYOUTS = 300|&quot; &quot;$strPath/server/common/constants.py&quot; else sed -i &quot;s|route(request.data,current_app.app_config, \\&quot;/tmp\\&quot;)|route(request.data,current_app.app_config)|&quot; &quot;$strPath/server/app/app.py&quot; sed -i &quot;s|MAX_LAYOUTS *= *[0-9]\\+|MAX_LAYOUTS = 300|&quot; &quot;$strPath/server/common/constants.py&quot; fi find ./cellxgene/server/ -name &quot;decode_fbs.py&quot; -exec cp {} $strPath/server/app/. \\; fi echo -e &quot;\\nls -l $strweb\\n&quot; ls -l $strweb 3.3 Communication between VIP and cellxgene web GUI Cellxgene client utilizes React Redux that is the official React binding for Redux. It lets your React components read data from a Redux store, and dispatch actions to the store to update data. So, this following code in config.sh appends “window.store = store;” to the end of client/src/reducers/index.js of cellxgene source code to expose the store to the browser. echo -e &quot;\\nwindow.store = store;&quot; &gt;&gt; cellxgene/client/src/reducers/index.js By doing this, Redux store holding client data and user selections are visible to VIP to access variables and dispatch actions to control cellxgene user interface. For example, Unselect / select a feature. GUI is refreshed automatically after dispatching. window.store.dispatch({type: &quot;categorical metadata filter deselect&quot;, metadataField: &quot;louvain&quot;, categoryIndex: 5}) window.store.dispatch({type: &quot;categorical metadata filter select&quot;, metadataField: &quot;louvain&quot;, categoryIndex: 5}) Get the state of a just finished action and synchronize gene input and cell selections from main window to VIP if corresponding action was performed. const unsubscribe = window.store.subscribe(() =&gt; { if (window.store.getState()[&quot;@@undoable/filterState&quot;].prevAction) { actionType = window.store.getState()[&quot;@@undoable/filterState&quot;].prevAction.type; if (actionType.includes(&quot;user defined gene success&quot;) || actionType.includes(&quot;store current cell selection as differential set&quot;)) { sync(); } } }); 3.4 Diffxpy Integration This is the sample pseudocode, please see VIPInterface.py for actual implementation. import scanpy as sc import pandas as pd import diffxpy.api as app # set 1 of cells as cell1; set 2 of cells as cell2 with app.get_data_adaptor() as data_adaptor: X1 = data_adaptor.data.X[cell1] X2 = data_adaptor.data.X[cell2] adata = sc.AnnData(pd.concat([X1,X2]),pd.DataFrame([&#39;grp1&#39; for i in range(X1.shape[0])]+[&#39;grp2&#39; for i in range(X2.shape[0])],columns=[&#39;comGrp&#39;])) deg = de.test.two_sample(adata,&#39;comGrp&#39;).summary() #deg is a dataframe contains the folloing columns [&#39;gene&#39;,&#39;log2fc&#39;,&#39;pval&#39;,&#39;qval&#39;] 3.5 Create a h5ad file from Seurat object First, export the following from Seurat object in R: expression matrix (assume normalized), metadata and coordinates (pca, tsne, umap) as separate txt files. Next in Python, create an AnnData object from 10x (scanpy.read_h5ad function) as a starting point. Then replace the expression matrix, meta data and coordinates as shown in the following Python code block to generate a h5ad file. import sys import scanpy as sc import pandas as pd import numpy as np import seaborn as sns from numpy import ndarray, unique from scipy.sparse.csc import csc_matrix adata= sc.read_h5ad(&quot;previous generated .h5ad&quot;) # read clustering res xpca = pd.read_csv(“./data/harmony_clustered.h5ad.pca_coordinates.txt&quot;, sep=&#39;\\t&#39;, encoding=&#39;utf-8&#39;) xtsne = pd.read_csv(“./data/harmony_clustered.h5ad.tsne_coordinates.txt&quot;, sep=&#39;\\t&#39;, encoding=&#39;utf-8&#39;) xumap = pd.read_csv(“./data/harmony_clustered.h5ad.umap_coordinates.txt&quot;, sep=&#39;\\t&#39;, encoding=&#39;utf-8&#39;) xobs = pd.read_csv(“./data/harmony_clustered.h5ad.meta_data.txt&quot;, sep=&#39;\\t&#39;, encoding=&#39;utf-8&#39;) xpca.set_index(&#39;index&#39;, inplace=True) xtsne.set_index(&#39;index&#39;, inplace=True) xumap.set_index(&#39;index&#39;, inplace=True) xobs.set_index(&#39;index&#39;, inplace=True) adata.obsm[&#39;X_pca&#39;] = np.array(xpca.loc[adataRaw.obs.index]) adata.obsm[&#39;X_tsne&#39;] = np.array(xtsne.loc[adataRaw.obs.index]) adata.obsm[&#39;X_umap&#39;] = np.array(xumap.loc[adataRaw.obs.index]) adata.obs = xobs.loc[adataRaw.obs.index] # this is a pandas dataframe # read in expression matrix as numpy.ndarray exp_mat = np.loadtxt(fname =”expression matrix .txt&quot;) adata.X = exp_mat # convert dense matrix into sparse matrix to save storage space and memory usage adata.X = csc_matrix(adata.X)_matrix # add short description and initial graph settings. “|” and “by” are delimiters for VIP to parse the initial settings. Please follow the same rule for your own h5ad files. adata.obs[&#39;&gt;Description&#39;] = [&#39;Human brain snRNAseq 46k cells (MS Nature 2019 Schirmer et al.); data normalized, log transformed and scaled UMI; platform - 10X v2 chemistry | embedding by umap; color by cell_type&#39;]*adata.n_obs # Then last step to save h5ad: adata.write_h5ad(&quot;final output.h5ad&quot;) When the h5ad file is uploaded to cellxgeneVIP, AnnData.X matrix is to be used for visualization and DEG analysis. By default, the data (e.g, raw count matrix) is assumed to be unscaled , however, if the data have been scaled or normalized, the user needs to turn off the option ‘Scale data to unit variance for plotting:’ in ‘Global Setting’. 3.6 Prepare Spatial Data for Visualization 3.6.1 10X visium data This is the sample script for the spatial demo data set adapted from cellxgene_VIP spatial transcriptomics notebook. Please go to cellxgene_VIP spatial transcriptomics notebook to check the intermediate outputs. 3.6.1.1 Download input demo data wget -O 10X_ST_demo.tar.gz https://zenodo.org/record/5765589/files/10X_ST_demo.tar.gz?download=1 tar -zxvf 10X_ST_demo.tar.gz 3.6.1.2 Using python to prepare 10X visium spatial data import pandas as pd import numpy as np import sys, getopt import matplotlib.pyplot as plt import seaborn as sns import copy import numpy as np from PIL import Image, ImageOps import scanpy as import anndata # change directory to 10X_ST_demo which is just downloaded, if in current directory os.chdir(&#39;./10X_ST_demo&#39;) inputfile=&#39;inputfiles.txt&#39; samples = pd.read_csv(inputfile, header = None)[0] def read_each(i): adata = sc.read_visium(i) adata.var_names_make_unique() # flip Y axis to show correctly in cellxgene VIP adata.obsm[&#39;spatial&#39;][:,1] = -adata.obsm[&#39;spatial&#39;][:,1] return(adata) adatals = [read_each(i) for i in samples] sampleIDs = samples.str.extract(r&#39;10X_demo_data_(.*)&#39;) sampleIDs = &quot;V1_&quot;+ sampleIDs adata_merge = sc.AnnData.concatenate(*adatals, batch_key=&#39;sample&#39;, join=&#39;outer&#39;, batch_categories= sampleIDs[0].astype(&quot;category&quot;)) for i in list(range(len(adatals))): print(i) # add back the spatial coordinates as separate embeddings adata_merge.obsm[&#39;X_spatial_&#39;+list(adatals[i].uns[&quot;spatial&quot;])[0]] = np.zeros(adata_merge.obsm[&#39;spatial&#39;].shape) adata_merge.obsm[&#39;X_spatial_&#39;+list(adatals[i].uns[&quot;spatial&quot;])[0]][np.where(adata_merge.obs[&#39;sample&#39;]==list(adatals[i].uns[&quot;spatial&quot;])[0])] = adatals[i].obsm[&#39;spatial&#39;] adata_merge.uns[&#39;spatial&#39;] = dict() for i in list(range(len(adatals))): adata_merge.uns[&#39;spatial&#39;][&quot;spatial_&quot;+list(adatals[i].uns[&quot;spatial&quot;])[0]] = adatals[i].uns[&#39;spatial&#39;][list(adatals[i].uns[&quot;spatial&quot;])[0]] # QC metric adata_merge.var[&quot;mt&quot;] = adata_merge.var_names.str.startswith(&quot;MT-&quot;) sc.pp.calculate_qc_metrics(adata_merge, qc_vars=[&quot;mt&quot;], inplace=True) # QC plots fig, axs = plt.subplots(1, 4, figsize=(15, 4)) sns.distplot(adata_merge.obs[&quot;total_counts&quot;], kde=False, ax=axs[0]) sns.distplot(adata_merge.obs[&quot;total_counts&quot;][adata_merge.obs[&quot;total_counts&quot;] &lt; 10000], kde=False, bins=40, ax=axs[1]) sns.distplot(adata_merge.obs[&quot;n_genes_by_counts&quot;], kde=False, bins=60, ax=axs[2]) sns.distplot(adata_merge.obs[&quot;n_genes_by_counts&quot;][adata_merge.obs[&quot;n_genes_by_counts&quot;] &lt; 4000], kde=False, bins=60, ax=axs[3]) # filtering, turn this off to keep all spots for visualization also cutoffs are case-by-case based on the QC plots #sc.pp.filter_cells(adata, min_counts=5000) #sc.pp.filter_cells(adata, max_counts=35000) #adata = adata[adata.obs[&quot;pct_counts_mt&quot;] &lt; 20] #print(f&quot;#cells after MT filter: {adata.n_obs}&quot;) #sc.pp.filter_genes(adata, min_cells=10) # normalization, log1p transformation and select HVGs sc.pp.normalize_total(adata_merge, inplace=True) sc.pp.log1p(adata_merge) sc.pp.highly_variable_genes(adata_merge, flavor=&quot;seurat&quot;, n_top_genes=2000) # PCA, UMAP and clustering by leiden sc.pp.pca(adata_merge) sc.pp.neighbors(adata_merge) sc.tl.umap(adata_merge) sc.tl.leiden(adata_merge, key_added=&quot;clusters&quot;) # collect sample names sampleNames = list() for f in list(adata_merge.obsm): if &quot;spatial_&quot; in f: # search for the pattern library_id=f.replace(&quot;X_spatial_&quot;,&quot;&quot;) # parse the string and get the sample id #library_id=library_id.replace(&quot;V1_&quot;,&quot;&quot;) sampleNames.append(library_id) from PIL import Image spatial=adata_merge.uns[&quot;spatial&quot;] dim=&#39;&#39; import math if dim==&#39;&#39;: height = math.ceil(math.sqrt(len(samples))) width = math.ceil(len(samples)/height) else: width,height = dim.split(&#39;x&#39;) idx = 0 size=700 #creates a new empty image, RGB mode, and size 1400 by 1400. new_im = Image.new(&#39;RGB&#39;, (size*width,size*height)) for i in range(0,size*width,size): for j in range(0,size*height,size): # load the image from the object #im = Image.fromarray((spatial[&quot;spatial_V1_&quot;+samples[idx]][&quot;images&quot;][&quot;lowres&quot;]* 255).round().astype(np.uint8)) # found a solution to covert float32 to unit8 im = Image.fromarray((spatial[&quot;spatial_&quot;+sampleNames[idx]][&quot;images&quot;][&quot;lowres&quot;]* 255).round().astype(np.uint8)) # found a solution to covert float32 to unit8 # paste images together new_im.paste(im, (j,i)) print(idx) idx = idx+1 if idx&gt;=len(sampleNames): break # fake a adata.uns by providing merged lowres image and scale factors 1 adata_merge.uns[&#39;spatial&#39;][&#39;spatial_Merged&#39;] = copy.deepcopy(adata_merge.uns[&#39;spatial&#39;][list(adata_merge.uns[&#39;spatial&#39;])[0]]) adata_merge.uns[&#39;spatial&#39;][&#39;spatial_Merged&#39;][&#39;images&#39;][&quot;hires&quot;] = np.asarray(new_im) adata_merge.uns[&#39;spatial&#39;][&#39;spatial_Merged&#39;][&#39;images&#39;][&quot;lowres&quot;] = np.asarray(new_im) adata_merge.uns[&#39;spatial&#39;][&#39;spatial_Merged&#39;][&#39;scalefactors&#39;][&#39;tissue_lowres_scalef&#39;] = 1 adata_merge.uns[&#39;spatial&#39;][&#39;spatial_Merged&#39;][&#39;scalefactors&#39;][&#39;tissue_hires_scalef&#39;] = 1 # add back the spatial coordinates as separate embeddings idx = 0 adata_merge.obsm[&#39;X_spatial_Merged&#39;] = adata_merge.obsm[&#39;spatial&#39;] for i in range(0,size*width,size): for j in range(0,size*height,size): #library_id=&#39;spatial_V1_&#39;+samples[idx] # parse the string and get the sample id library_id=&#39;spatial_&#39;+sampleNames[idx] # parse the string and get the sample id print(library_id) tissue_lowres_scalef = spatial[library_id][&#39;scalefactors&#39;][&#39;tissue_lowres_scalef&#39;] adata_merge.obsm[&#39;X_spatial_Merged&#39;][np.where(adata_merge.obs[&#39;sample&#39;]==sampleNames[idx])] = copy.deepcopy(adatals[idx].obsm[&#39;spatial&#39;]) adata_merge.obsm[&#39;X_spatial_Merged&#39;][np.where(adata_merge.obs[&#39;sample&#39;]==sampleNames[idx]),1] = adatals[idx].obsm[&#39;spatial&#39;][:,1]*tissue_lowres_scalef - i adata_merge.obsm[&#39;X_spatial_Merged&#39;][np.where(adata_merge.obs[&#39;sample&#39;]==sampleNames[idx]),0] = adatals[idx].obsm[&#39;spatial&#39;][:,0]*tissue_lowres_scalef + j idx = idx+1 if idx&gt;=len(sampleNames): break outputfile = &#39;10X_data.h5ad&#39; adata_merge.write_h5ad(outputfile) 3.6.2 NanoString CosMx data This is the sample script for the spatial demo data set adapted from cellxgene_VIP public cosMx liver notebook. Please go to cellxgene_VIP public cosMx liver notebook to check the intermediate outputs. 3.6.2.1 Download input demo data Download the public cosMx data from NanoString website. The seurat object contains the expression, cell meta and transcript coordinates(some may contains cell boundaries). If the cell boundaries are not included in the seurat, they can be estimated from the transcript coordinates by cellPoly. The following will use Human Liver (RNA) as an example. 3.6.2.2 Export Expression, cell meta, transcript coordinate and Reduction UMAP from seurat object using R require(Seurat) require(CellPoly) require(dplyr) D &lt;- readRDS(&#39;LiverDataReleaseSeurat_newUMAP.RDS&#39;) saveSlideFOV &lt;- function(slide,fov){ selC &lt;- rownames(D@meta.data)[D@meta.data$fov==fov&amp;D@meta.data$slide_ID_numeric==slide] prefix &lt;- paste0(&quot;Slide&quot;,slide,&quot;_FOV&quot;,gsub(&quot; &quot;,&quot;0&quot;,format(fov,width=3))) data.table::fwrite(data.frame(gene=rownames(D@assays$RNA),D@assays$RNA[,selC]),paste0(prefix,&#39;_exp.csv&#39;)) data.table::fwrite(data.frame(cID=selC,D@meta.data[selC,]),paste0(prefix,&#39;_meta.csv&#39;)) data.table::fwrite(data.frame(cID=selC,D@reductions$approximateumap@cell.embeddings[selC,]),paste0(prefix,&#39;_UMAP.csv&#39;)) data.table::fwrite(data.frame(cID=selC,D@reductions$approximateUMAP_bySlide@cell.embeddings[selC,]),paste0(prefix,&#39;_slideUMAP.csv&#39;)) data.table::fwrite(D@misc$transcriptCoords[D@misc$transcriptCoords$fov==fov&amp;D@misc$transcriptCoords$slideID==slide,] %&gt;% dplyr::rename(cell_ID=cell_id),paste0(prefix,&#39;_tx.csv&#39;)) } saveSlideFOV(1,2) saveSlideFOV(1,3) 3.6.2.3 Extract cell boundaries from cell ID labeled tif file using python import cv2 import matplotlib.pyplot as plt import numpy as np import pandas as pd def extractCellBoundaryPolygon(fov): print(fov) img = plt.imread((&#39;NormalLiverFiles/CellStatsDir/FOV%*d/CellLabels_F%*d.tif&#39;%(3,fov,3,fov)).replace(&quot; &quot;,&quot;0&quot;)) contours = [] nStep = int(np.max(img)/10) for i in range(1,np.max(img)+1): if i%nStep==0: print(&quot;%d0%%&quot;%(i/nStep),end=&quot; &quot;) A = img.copy() A[A!=i]=0 _, B = cv2.threshold(A, i-0.5, 255, cv2.THRESH_BINARY) A,_ = cv2.findContours(B.astype(np.uint8),cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) A = pd.DataFrame(A[0].reshape(len(A[0]),2),columns=[&#39;x_FOV_px&#39;,&#39;y_FOV_px&#39;]) A[&#39;cell_ID&#39;] = &#39;c_1_%d_%d&#39;%(fov,i) contours.append(A.copy()) print() return pd.concat(contours) extractCellBoundaryPolygon(2).to_csv(&#39;Slide1_FOV002_cellPolygons.csv&#39;,index=False) extractCellBoundaryPolygon(3).to_csv(&#39;Slide1_FOV003_cellPolygons.csv&#39;,index=False) 3.6.2.3.1 The function to read one FOV data import os, re import pandas as pd import anndata as ad import matplotlib.pyplot as plt cellID_col = &#39;cell_ID&#39; suf_px={&#39;local&#39;:&#39;_local_px&#39;,&#39;global&#39;:&#39;_global_px&#39;} sample_col = &#39;library_id&#39; cosMx_uns = &#39;cosMx&#39; cell_uns = &#39;cell_polygons&#39; transc_uns = &#39;tx_loc&#39; img_uns = &#39;images&#39; def readOneCapture(strExp, # the path to the expression matrix of a FOV strMeta, # the path to the cell meta table matrix of a FOV strReduc, # a list of the paths to the expression matrix of a FOV strTargetCoord, # the path to the target coordinate of a FOV strCellBoundaries, # the path to the cell boundary polygons of a FOV strImg, # the image associated with the FOV, like histology please make sure the scale/rotation matching the coordinates sID, #the unique name of the FOV cell_column=&#39;cell_id&#39;, lpx=&#39;_FOV_px&#39;, # the column suffix which indicate the location on each FOV image in cell meta table gpx=4256 # the column suffix which indicate the location on the global of all FOV images in cell meta table. If a numeric, a fake global will be created vertically stack all FOVs ): # exp print(&quot; exp&quot;) gExp = pd.read_csv(strExp,index_col=0).T gExp.columns.name=None # meta print(&quot; meta&quot;) cInfo = pd.read_csv(strMeta,index_col=0) cID = cInfo.index.intersection(gExp.index) # create anndata print(&quot; create AnnData&quot;) D = ad.AnnData(X=gExp.loc[cID,:],obs=cInfo.loc[cID,:]) del gExp # add histology image D.uns[cosMx_uns]={sID:{}} D.uns[cosMx_uns][sID][img_uns]=plt.imread(strImg) # add px coordinates print(&quot; add reduction&quot;) D.obsm[&#39;X_FOV_local&#39;] = cInfo.loc[cID,[_ for _ in cInfo.columns if _.endswith(lpx)]].to_numpy(&#39;float32&#39;) if isinstance(gpx, (int, float)): FOV_global = cInfo.loc[cID,[_ for _ in cInfo.columns if _.endswith(lpx)]]# FOV_global.iloc[:,0] += gpx FOV_global.iloc[:,1] = D.uns[cosMx_uns][sID][img_uns].shape[1]-FOV_global.iloc[:,1]-1 # seems like the y(height) is flipped from the image and coordinates of transcript/cell boundaries D.obsm[&#39;X_FOV_global&#39;] = FOV_global.to_numpy(&#39;float32&#39;) else: D.obsm[&#39;X_FOV_global&#39;] = cInfo.loc[cID,[_ for _ in cInfo.columns if _.endswith(lpx)]].to_numpy(&#39;float32&#39;) for oneF in strReduc: reducName = re.sub(&quot;.csv&quot;,&quot;&quot;,os.path.basename(oneF).split(&quot;_&quot;)[-1]) D.obsm[&#39;X_&#39;+reducName] = pd.read_csv(oneF,index_col=0).loc[cID,].to_numpy(&#39;float32&#39;) # add cell boundaries print(&quot; add cell boundaries&quot;) X = pd.read_csv(strCellBoundaries) X.columns = [re.sub(cell_column,cellID_col,re.sub(lpx,suf_px[&#39;local&#39;],_)) for _ in X.columns] if isinstance(gpx, (int, float)): X[&#39;x&#39;+suf_px[&#39;global&#39;]] = X[&#39;x&#39;+suf_px[&#39;local&#39;]] + gpx X[&#39;y&#39;+suf_px[&#39;global&#39;]] = X[&#39;y&#39;+suf_px[&#39;local&#39;]] else: X.columns = [re.sub(gpx,suf_px[&#39;global&#39;],_) for _ in X.columns] D.uns[cosMx_uns][sID][cell_uns] = X # add transcript coordinates print(&quot; add transcript coordinates&quot;) X = pd.read_csv(strTargetCoord) X.columns = [re.sub(cell_column,cellID_col,re.sub(lpx,suf_px[&#39;local&#39;],_)) for _ in X.columns] if isinstance(gpx, (int, float)): X[&#39;x&#39;+suf_px[&#39;global&#39;]] = X[&#39;x&#39;+suf_px[&#39;local&#39;]] + gpx X[&#39;y&#39;+suf_px[&#39;global&#39;]] = X[&#39;y&#39;+suf_px[&#39;local&#39;]] else: X.columns = [re.sub(gpx,suf_px[&#39;global&#39;],_) for _ in X.columns] D.uns[cosMx_uns][sID][transc_uns] = X return D 3.6.2.3.2 Use two FOVs from human liver data as an example samples = {} for i in [2,3]: samples[&#39;Normal%d&#39;%i] = {} for one in [&#39;exp&#39;,&#39;meta&#39;,&#39;cellPolygons&#39;,&#39;tx&#39;,&#39;reduct&#39;,&#39;img&#39;]: if one == &#39;reduct&#39;: samples[&#39;Normal%d&#39;%i][one] = [&#39;Slide1_FOV00%d_UMAP.csv&#39;%i,&#39;Slide1_FOV00%d_slideUMAP.csv&#39;%i] elif one == &#39;img&#39;: samples[&#39;Normal%d&#39;%i][one] = &#39;NormalLiverFiles/CellStatsDir/CellComposite/CellComposite_F00%d.jpg&#39;%(i) # this can be replaced with the right histology image else:# samples[&#39;Normal%d&#39;%i][one] = &#39;Slide1_FOV00%d_%s.csv&#39;%(i,one) adatas = [] w = 0 for sID in samples.keys(): D = readOneCapture(samples[sID][&#39;exp&#39;], samples[sID][&#39;meta&#39;], samples[sID][&#39;reduct&#39;], samples[sID][&#39;tx&#39;], samples[sID][&#39;cellPolygons&#39;], samples[sID][&#39;img&#39;], sID, gpx=w ) # If no global coordinates, a fake one align all of the input vertically w += D.uns[cosMx_uns][sID][img_uns].shape[1] adatas.append(D) adata = ad.AnnData.concatenate(*adatas, join=&quot;outer&quot;, batch_categories=list(samples.keys()), batch_key=sample_col, index_unique=None, uns_merge=&#39;unique&#39;) adata.uns[cosMx_uns][&#39;keys&#39;] = {&#39;%s_px&#39;%i:{j:&#39;%s%s&#39;%(j,suf_px[i]) for j in [&#39;x&#39;,&#39;y&#39;]} for i in suf_px} adata.uns[cosMx_uns][&#39;keys&#39;][&#39;cell&#39;] = cell_uns adata.uns[cosMx_uns][&#39;keys&#39;][&#39;tx_loc&#39;] = transc_uns adata.uns[cosMx_uns][&#39;keys&#39;][&#39;img&#39;] = img_uns adata.uns[cosMx_uns][&#39;keys&#39;][&#39;tx_col&#39;] = &#39;target&#39; adata.write(&quot;human_liver.h5ad&quot;) 3.6.2.4 Check the coordinates among cell boundaries, transcript locations and the image are aligned import random import anndata as ad import numpy as np import matplotlib.pyplot as plt #adata = ad.read_h5ad(&#39;human_liver.h5ad&#39;) sID= &#39;Normal3&#39; def showImg(img): plt.figure(figsize=(12, 12)) plt.imshow(img,cmap=&#39;gray&#39;) plt.axis(&#39;off&#39;) plt.show() plt.close() def bresenham_line(pt1,pt2): x1,y1 = pt1 x2,y2 = pt2 points = [] dx = abs(x2 - x1) dy = abs(y2 - y1) sx = 1 if x1 &lt; x2 else -1 sy = 1 if y1 &lt; y2 else -1 error = dx - dy while x1 != x2 or y1 != y2: points.append((x1, y1)) e2 = 2 * error if e2 &gt; -dy: error -= dy x1 += sx if e2 &lt; dx: error += dx y1 += sy points.append((x2, y2)) return points def loc_img(pt,imgH): x,y = pt return((round(y),round(x)))#imgH-y-1 def square_integer(ct,halfS): x_center, y_center = ct coordinates_in_square = [] for x in range(x_center - halfS, x_center + halfS + 1): for y in range(y_center - halfS, y_center + halfS + 1): coordinates_in_square.append((x, y)) return coordinates_in_square cosMxKey=&#39;cosMx&#39; keys = adata.uns[cosMxKey][&#39;keys&#39;] cosMxArray={} cood_pair={} imgC = adata.uns[cosMxKey][sID][keys[&#39;img&#39;]].copy() cell_color= &#39;ffffff&#39; #&#39;000000&#39; rgb = np.array(tuple(int(cell_color[i:i+2], 16) for i in (0, 2, 4)),dtype=&#39;uint8&#39;) cellB = adata.uns[cosMxKey][sID][keys[&#39;cell&#39;]] for i in cellB.cell_ID.unique(): oneC = cellB[cellB.cell_ID==i].reset_index(drop=True) N = oneC.shape[0] for j in range(N): p = bresenham_line(loc_img((oneC[keys[&#39;local_px&#39;][&#39;x&#39;]][j%N],oneC[keys[&#39;local_px&#39;][&#39;y&#39;]][j%N]),imgC.shape[1]), loc_img((oneC[keys[&#39;local_px&#39;][&#39;x&#39;]][(j+1)%N],oneC[keys[&#39;local_px&#39;][&#39;y&#39;]][(j+1)%N]),imgC.shape[1])) for a in p: imgC[a]=rgb showImg(imgC) # cell boundries with transcript within the same randomly selected 10 cell imgC = np.ones((adata.uns[cosMxKey][sID][keys[&#39;img&#39;]].shape[0],adata.uns[cosMxKey][sID][keys[&#39;img&#39;]].shape[1],3),dtype=&#39;uint8&#39;)*255 cell_color=&quot;000000&quot; rgb = np.array(tuple(int(cell_color[i:i+2], 16) for i in (0, 2, 4)),dtype=&#39;uint8&#39;) cID = random.sample(list(cellB.cell_ID.unique()),10) txLoc = adata.uns[&#39;cosMx&#39;][sID][keys[&#39;tx_loc&#39;]] for i in cID: oneC = cellB[cellB.cell_ID==i].reset_index(drop=True) N = oneC.shape[0] for j in range(N): p = bresenham_line(loc_img((oneC[keys[&#39;local_px&#39;][&#39;x&#39;]][j%N],oneC[keys[&#39;local_px&#39;][&#39;y&#39;]][j%N]),imgC.shape[1]), loc_img((oneC[keys[&#39;local_px&#39;][&#39;x&#39;]][(j+1)%N],oneC[keys[&#39;local_px&#39;][&#39;y&#39;]][(j+1)%N]),imgC.shape[1])) for a in p: imgC[a]=rgb col = &#39;aa0000&#39; rgb = np.array(tuple(int(col[i:i+2], 16) for i in (0, 2, 4)),dtype=&#39;uint8&#39;) for i in txLoc.index[txLoc[cellID_col].isin(cID)].tolist(): for a in square_integer(loc_img((txLoc[keys[&#39;local_px&#39;][&#39;x&#39;]][i],txLoc[keys[&#39;local_px&#39;][&#39;y&#39;]][i]),imgC.shape[1]),4): imgC[a] = rgb showImg(imgC) "],["helpful-tips.html", "Chapter 4 Helpful Tips 4.1 Handle nulls in categorical annotation 4.2 Display full traceback stack for debugging in VIP 4.3 Pitfall of using special characters 4.4 Potential use for bulk or pseudo bulk sample dataset 4.5 Common mistakes in naming 4.6 Loading h5ad file generated by SeuratDisk from R", " Chapter 4 Helpful Tips 4.1 Handle nulls in categorical annotation Such nulls in categorical annotation would cause trouble in VIP because it cannot be converted to string. Here is how to handle it, let’s call the annotation X_annotation: # Cast to str from categorical adata.obs = adata.obs.astype({&#39;X_annotation&#39;:&#39;str&#39;}) # replace all of nan by ‘nan’ adata.obs[&quot;X_annotation &quot;][adata.obs[&quot;X_annotation &quot;].isnull()] = &#39;nan&#39; 4.2 Display full traceback stack for debugging in VIP It follows the global setting. Please set “—verbose” to launch cellxgene server. 4.3 Pitfall of using special characters In the mode which allows user to create manual annotation in cellxgene, user should try to avoid using hyphen (“-”) in name label. It would cause client-side issue. Please try to use underscores. 4.4 Potential use for bulk or pseudo bulk sample dataset Once the data matrix is replaced by sample x gene matrix, cellxgene VIP framework can handle regular bulk / pseudobulk RNAseq datasets. Simply replace “cells” by “samples”. All plotting functions sould still work. 4.5 Common mistakes in naming “B internediate” with extra space in the end of a cell type “CD4 naive” where “n” should be “N” to match the cell type used in the h5ad file 4.6 Loading h5ad file generated by SeuratDisk from R SeuratDisk provides a convenient way to convert a Seurat object into the h5ad format. However, there are cases cellxgene VIP window would be blank when loading such h5ad file. To fix the issue, simply run the following python code to re-generate the h5ad file, which should solve the blank VIP window issue. import scanpy as sc adata = sc.read_h5ad(&lt;input h5ad&gt;) adata.__dict__[&#39;_raw&#39;].__dict__[&#39;_var&#39;] = adata.__dict__[&#39;_raw&#39;].__dict__[&#39;_var&#39;].rename(columns={&#39;_index&#39;: &#39;features&#39;}) "],["web-resource.html", "Chapter 5 Web Resource 5.1 Cellxgene VIP 5.2 Cellxgene 5.3 Python packages 5.4 Others", " Chapter 5 Web Resource 5.1 Cellxgene VIP cellxgene VIP source code: https://github.com/interactivereport/cellxgene_VIP cellxgene VIP demo sites: https://cellxgenevip-ms.bxgenomics.com [Schirmer / Rowitch MS, Human brain snRNAseq 46k cells, Nature 2019 Schirmer et al] 5.2 Cellxgene cellxgene: https://github.com/chanzuckerberg/cellxgene cellxgene tutorial: https://cellgeni.readthedocs.io/en/latest/visualisations.html cellxgene features: https://chanzuckerberg.github.io/cellxgene/posts/gallery cellxgene data preparation: https://chanzuckerberg.github.io/cellxgene/posts/prepare.html 5.3 Python packages scanpy: https://github.com/theislab/scanpy scanpy plots: https://scanpy-tutorials.readthedocs.io/en/latest/visualizing-marker-genes.html diffxpy: https://github.com/theislab/diffxpy diffxpy tests: https://diffxpy.readthedocs.io/en/latest/tutorials.html#differential-testing 5.4 Others Benchmarking of interactive data visualization of single-cell RNAseq data — Batuhan Cakir : https://www.youtube.com/watch?v=3nH2xi_Ni6I sceasy: convertor of scRNA-Seq data formats https://github.com/cellgeni/sceasy jupytext: https://jupytext.readthedocs.io , Jupyter Notebooks as Markdown Documents, Julia, Python or R Scripts nbconvert: https://nbconvert.readthedocs.io , Convert a Jupyter .ipynb notebook document file into another static format including HTML, LaTeX, PDF, Markdown, and more R magic: https://rpy2.github.io/doc/latest/html/interactive.html#rmagic , Magic command interface for interactive work with R in ipython. %R and %%R are for the line mode where one line of R code will be executed, and the cell mode where a block of R code will run, respectively. "]]
